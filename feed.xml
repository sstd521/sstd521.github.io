<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://stayup.cn/</id><title>OneNote</title><subtitle>sstd521 OneNote.</subtitle> <updated>2022-09-18T23:58:32+08:00</updated> <author> <name>sstd521</name> <uri>https://stayup.cn/</uri> </author><link rel="self" type="application/atom+xml" href="https://stayup.cn/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://stayup.cn/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2022 sstd521 </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>jekyll basic abc</title><link href="https://stayup.cn/posts/article-name/" rel="alternate" type="text/html" title="jekyll basic abc" /><published>2021-11-30T00:00:00+08:00</published> <updated>2022-01-09T15:08:16+08:00</updated> <id>https://stayup.cn/posts/article-name/</id> <content src="https://stayup.cn/posts/article-name/" /> <author> <name>sstd521</name> </author> <summary> Create your new page using: $ bundle exec jekyll page "My New Page" preview on local bundle exec jekyll s </summary> </entry> <entry><title>迭代器与生成器</title><link href="https://stayup.cn/posts/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/" rel="alternate" type="text/html" title="迭代器与生成器" /><published>2019-02-24T21:36:51+08:00</published> <updated>2019-02-24T21:36:51+08:00</updated> <id>https://stayup.cn/posts/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</id> <content src="https://stayup.cn/posts/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/" /> <author> <name>sstd521</name> </author> <category term="编程学习" /> <summary> 迭代器与生成器 定义 定义：迭代器是一种特殊的对象，有一个next()方法，每次调用，都会返回一个结果。结果有两个属性，一个是value，表示表示下一个将要返回的值，另一个是done，它是一个布尔类型的值，表示是否还有更多可返回的值。 生成器是一种返回带迭代器的函数，定义时需要在function关键字后的星号（*），被调用时会自动创建一个迭代器，函数会用到新的关键字yield。生成器函数，每当执行完一条yield语句后函数就会自动停止执行。 function* createIterator(items) { for (let i = 0; i &amp;lt; items.length; i++) { yield items[i]; } } let iterator = createIterator([1,2]); // 创建迭代器 cons... </summary> </entry> <entry><title>cocos2d-x学习笔记</title><link href="https://stayup.cn/posts/cocos2d-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="cocos2d-x学习笔记" /><published>2018-05-16T01:24:42+08:00</published> <updated>2018-05-16T01:24:42+08:00</updated> <id>https://stayup.cn/posts/cocos2d-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id> <content src="https://stayup.cn/posts/cocos2d-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" /> <author> <name>sstd521</name> </author> <category term="编程学习" /> <summary> this._tableView = new cc.TableView(this,cc.size( this._useW, this._useH)); this._tableView.setDirection(cc.SCROLLVIEW_DIRECTION_VERTICAL); this._tableView.setPosition(cc.p(24,110)); this._tableView.setDelegate(this); this._tableView.setVerticalFillOrder(cc.TABLEVIEW_FILL_TOPDOWN); this.bg.addChild(this._tableView,10); this._tableView.reloadData(); cc.spriteFrameCache.addSpriteFrames(KFGJ.KFGJ... </summary> </entry> <entry><title>Lua学习笔记</title><link href="https://stayup.cn/posts/2-Lua/" rel="alternate" type="text/html" title="Lua学习笔记" /><published>2018-05-16T01:24:42+08:00</published> <updated>2018-05-16T01:24:42+08:00</updated> <id>https://stayup.cn/posts/2-Lua/</id> <content src="https://stayup.cn/posts/2-Lua/" /> <author> <name>sstd521</name> </author> <category term="编程学习" /> <summary> Lua Lua在设计上，从一开始就把简洁、高效、可移植性、可嵌入型、可扩展性等作为自己的目标。 数据类型 表、函数、线程、以及完全用户数据在 Lua 中被称为对象：变量并不真的持有它们的值，而仅保存了对这些对象的引用。 赋值、参数传递、函数返回，都是针对引用而不是针对值的操作， 这些操作均不会做任何形式的隐式拷贝。 基本类型 描述   数值(number) 内部以double表示   字符串(string) 总是以零结尾,但可以包含任意字符(包括零),因此并不等价于C字符串, 而是其超集   布尔(boolean) 只有“true”或者“fals... </summary> </entry> <entry><title>我所理解的cocos2d-x</title><link href="https://stayup.cn/posts/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84cocos2d-x/" rel="alternate" type="text/html" title="我所理解的cocos2d-x" /><published>2018-05-16T00:00:00+08:00</published> <updated>2018-05-16T00:00:00+08:00</updated> <id>https://stayup.cn/posts/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84cocos2d-x/</id> <content src="https://stayup.cn/posts/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84cocos2d-x/" /> <author> <name>sstd521</name> </author> <summary> 我所理解的cocos2d-x ###消息分发 消息机制一直是软件开发中减少模块之间耦合的标准方式。游戏中有大量的游戏对象，在这些对象之间通过消息传递而不是直接调用的方法会大大简化对象之间的交互和依赖。 野指针：指针指向的内存单元已经被释放，但是其他指针可能还指向它，这些内存可能已经被重新分配给其他对象，从而导致无法预测的结果。 内存泄漏：不再被使用的内存单元如果不被释放，就会一直占用内存单元，如果这些操作不断重复，就会导致内存占用不断增加。在游戏中，内存泄露引发的问题尤其严重，因为可能每一帧都在创建一个永远不会被回收的游戏对象。 C++有3种管理数据内存的方式，分别是自动存储、静态存储和动态存储。其中，静态存储用于存储一些在整个应用程序执行期间都存在的静态变量，动态存储用于存储通过new关键字分配的内存单元。自动变量是一个局部变量，其作用域为包含它的代码块所对应的作用域。 默... </summary> </entry> </feed>
