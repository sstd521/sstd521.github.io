[ { "title": "jekyll basic abc", "url": "/posts/article-name/", "categories": "", "tags": "", "date": "2021-11-30 00:00:00 +0800", "snippet": "Create your new page using:$ bundle exec jekyll page &quot;My New Page&quot;preview on localbundle exec jekyll s" }, { "title": "迭代器与生成器", "url": "/posts/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/", "categories": "编程学习", "tags": "JavaScript", "date": "2019-02-24 21:36:51 +0800", "snippet": "迭代器与生成器定义 定义：迭代器是一种特殊的对象，有一个next()方法，每次调用，都会返回一个结果。结果有两个属性，一个是value，表示表示下一个将要返回的值，另一个是done，它是一个布尔类型的值，表示是否还有更多可返回的值。 生成器是一种返回带迭代器的函数，定义时需要在function关键字后的星号（*），被调用时会自动创建一个迭代器，函数会用到新的关键字yield。生成器函数，每当执行完一条yield语句后函数就会自动停止执行。function* createIterator(items) { for (let i = 0; i &amp;lt; items.length; i++) { yield items[i]; }}let iterator = createIterator([1,2]); // 创建迭代器console.log(iterator.next()); // { value: 1, done: false }console.log(iterator.next()); // { value: 2, done: false }console.log(iterator.next()); // { value: undefined, done: true }特征 可迭代对象具有Symbol.iterator属性。生成器默认会为属性Symbol.iterator赋值，所有通过生成器创建的迭代器都是可迭代对象。function isIterableObject(object) { return typeof object[Symbol.iterator] === `function`;}let iterator = createIterator([1,2]); // 创建迭代器console.log(isIterableObject(iterator)); // truefor-of 循环每次执行一次都会调用迭代对象的next()方法，并将迭代器返回的结果对象的value属性存储在一个变量中，循环将持续执行这一过程，直返回对象的done属性的值为 true。如果只需迭代数组或集合中的值，推荐用for-of循环。可迭代对象默认情况下，开发者定义的对象都是比可迭代对象，但如果给Symbol.iterator 属性添加一个生成器，则可以将其变为可迭代对象。let collection = { items: [], * [Symbol.iterator]() { for (let item of this.items) { yield item; } }};collection.items.push(3);collection.items.push(31);collection.items.push(32);for (let i of collection) { console.log(i);}给迭代器传参function *createIterator() { let first = yield 1 ; let second = yield first + 2; yield second +3;}let iterator1 = createIterator();console.log(iterator1.next());console.log(iterator1.next(11));console.log(iterator1.next(20));console.log(iterator1.next(10));console.log(iterator1.next());// { value: 1, done: false }// { value: 13, done: false }// { value: 23, done: false }// { value: undefined, done: true }// { value: undefined, done: true }" }, { "title": "cocos2d-x学习笔记", "url": "/posts/cocos2d-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/", "categories": "编程学习", "tags": "cocos2d-x", "date": "2018-05-16 01:24:42 +0800", "snippet": "this._tableView = new cc.TableView(this,cc.size( this._useW, this._useH));this._tableView.setDirection(cc.SCROLLVIEW_DIRECTION_VERTICAL);this._tableView.setPosition(cc.p(24,110));this._tableView.setDelegate(this);this._tableView.setVerticalFillOrder(cc.TABLEVIEW_FILL_TOPDOWN);this.bg.addChild(this._tableView,10);this._tableView.reloadData();cc.spriteFrameCache.addSpriteFrames(KFGJ.KFGJImagePath + &quot;xiaomei.plist&quot;,KFGJ.KFGJImagePath + &quot;xiaomei.png&quot;);cc.spriteFrameCache.removeSpriteFrameByName(KFGJ.KFGJImagePath + &quot;xiaomei.plist&quot;);var cellBgSprite = new cc.Sprite(&quot;#&quot;+this.faceNameByIdex(idxInVector));var spriteFrame = cc.spriteFrameCache.getSpriteFrame(this.faceNameByIdex(idxInVector));var _img = cell.getChildByTag(i + 1).getChildByTag(159);if(_img){ _img.initWithSpriteFrame(spriteFrame);}faceNameByIdex:function(idx){ var name = &quot;majfacepic_88.png&quot;; switch(parseInt(idx)) { case 1:name =&quot;majfacepic_qiuhaopai.png&quot;;break; case 2:name =&quot;majfacepic_yeah.png&quot;;break; case 3:name =&quot;majfacepic_cry.png&quot;;break; case 4:name =&quot;majfacepic_daji.png&quot;;break; case 5:name =&quot;majfacepic_caoxiao.png&quot;;break; case 6:name =&quot;majfacepic_yuan.png&quot;;break; case 7:name =&quot;majfacepic_fahuo.png&quot;;break; case 8:name =&quot;majfacepic_zan.png&quot;;break; case 9:name =&quot;majfacepic_likeyou.png&quot;;break; case 10:name =&quot;majfacepic_sa.png&quot;;break; case 11:name =&quot;majfacepic_win.png&quot;;break; case 12:name =&quot;majfacepic_jiuyang.png&quot;;break; case 13:name =&quot;majfacepic_sleep.png&quot;;break; case 14:name =&quot;majfacepic_lose.png&quot;;break; case 15:name =&quot;majfacepic_taokong.png&quot;;break; case 16:name =&quot;majfacepic_exin.png&quot;;break; case 17:name =&quot;majfacepic_pale.png&quot;;break; case 18:name =&quot;majfacepic_siluo.png&quot;;break; case 19:name =&quot;majfacepic_haohuai.png&quot;;break; case 20:name =&quot;majfacepic_88.png&quot;;break; default:break; } return name;},var loginPlayerId = KFGJ.LoginCtrl.getInstance()._loginPlayerId.toNumber();Menu 菜单(Menu),常用于实现菜单按钮。Menu类驱动一个菜单的主类，它包含描述文字、按钮和触发器的菜单列表。在使用过程中，首先你需要创建一个或多个菜单项(MenuItem)，然后用这些菜单项初始化菜单(Menu)对象，最后将这个初始化了的菜单对象添加到Layer中。var menu = new cc.Menu();menu.setPosition(0,0);bg.addChild( menu );//不同意加入牌局按钮var normalBg = new cc.Sprite(KFGJ.KFGJImagePath + &quot;tdh_btn_general_green.png&quot;);var heightBg = new cc.Sprite(KFGJ.KFGJImagePath + &quot;tdh_btn_general_green.png&quot;);heightBg.setColor(cc.color(100 , 100 , 100));var refustItem = new cc.MenuItemSprite(normalBg, heightBg, this.btnClick, this );refustItem.setPosition(bg.getContentSize().width / 2 - 10 , 35 );//205refustItem.setAnchorPoint(1, 0);refustItem.setTag( 1000 );//refustItem.setScale(0.7);menu.addChild( refustItem );var refusttb = new cc.LabelBMFont(&quot;取消&quot;, KFGJ.KFGJFontsPath + &quot;btn_gold.fnt&quot;);refusttb.setPosition(refustItem.getContentSize().width / 2 , refustItem.getContentSize().height / 2 + 5);refustItem.addChild(refusttb);var normalAgree = new cc.Sprite(KFGJ.KFGJImagePath + &quot;tdh_btn_general_orange.png&quot;);var heightAgree = new cc.Sprite(KFGJ.KFGJImagePath + &quot;tdh_btn_general_orange.png&quot;);heightAgree.setColor(cc.color(100 , 100 , 100));var agreeItem = new cc.MenuItemSprite(normalAgree, heightAgree, this.btnClick, this );agreeItem.setPosition(bg.getContentSize().width / 2 + 10 , 35 );//205agreeItem.setTag( 1001 );//agreeItem.setScale(0.7);agreeItem.setAnchorPoint(0, 0);menu.addChild( agreeItem );var agreetb = new cc.LabelBMFont(&quot;确定&quot;, KFGJ.KFGJFontsPath + &quot;btn_gold.fnt&quot;);agreetb.setPosition(agreeItem.getContentSize().width / 2 , agreeItem.getContentSize().height / 2 + 5);agreeItem.addChild(agreetb);" }, { "title": "Lua学习笔记", "url": "/posts/2-Lua/", "categories": "编程学习", "tags": "Lua", "date": "2018-05-16 01:24:42 +0800", "snippet": "Lua Lua在设计上，从一开始就把简洁、高效、可移植性、可嵌入型、可扩展性等作为自己的目标。数据类型 表、函数、线程、以及完全用户数据在 Lua 中被称为对象：变量并不真的持有它们的值，而仅保存了对这些对象的引用。 赋值、参数传递、函数返回，都是针对引用而不是针对值的操作， 这些操作均不会做任何形式的隐式拷贝。 基本类型 描述   数值(number) 内部以double表示   字符串(string) 总是以零结尾,但可以包含任意字符(包括零),因此并不等价于C字符串, 而是其超集   布尔(boolean) 只有“true”或者“false”两个值。nil → false，others → true   函数(function) Lua的关键概念之一。不简单等同于C的函数或函数指针。   表(table) 异构的Hash表。Lua的关键概念之一。   userdata 用户(非脚本用户)定义的C数据结构。脚本用户只能使用它,不能定义。   线程(thread) Lua协作线程(coroutine),与一般操作系统的抢占式线程不一样。   nil 为初始化的值，逻辑值为false。   and 且&amp;amp;&amp;amp;or 或||not 取反！函数 函数用关键字function定义函数，以关键字end结束 局部变量用关键字local定义。如果没有用local定义，即使在函数内部定义的变量也是全局变量! 函数可以返回多个值:function foo(a,b,c,...) local sum = a+b return sum,c --函数可以返回多个值 end 表定义表(Table)的方式local b = { x = 1, [&quot;hello&quot;] = &quot;world!&quot; }访问表的成员通过“.”或者“[]”运算符来访问表的成员。 1. 注意：表达式a.b等价于a[“b”]，但不等价于a[b] 除了nil，都可以作为表项的键和值 给一个表项的值赋nil意味着从表中删除这一项，比如令b.x = nil,则把表b中键为“x”的项删除。 如果访问一个不存在的表项,其值也是nil，比如有c = a.b,但表a中没有键为“b”的项，则c等于nil。 键值对之间使用等号。&amp;lt;/b&amp;gt;字符串字符串的链接..local str = &quot;Hi &quot; .. &quot;Lua&quot; -- Hi Lua字符串的截取，索引从1开始string.sub(str, fromIndex [, endIndex])string.sub(&quot;Hello Lua user&quot;, 7) -- Lua userstring.sub(&quot;Hello Lua user&quot;, 7, 9) -- Luastring.sub(&quot;Hello Lua user&quot;, -8) -- Lua userstring.sub(&quot;Hello Lua user&quot;, -8, 9) -- Luastring.sub(&quot;Hello Lua user&quot;, -8, -6) -- Lua常用方法string.len(&quot;Alma&quot;) -- &quot;4&quot;string.format(&quot;%d %s&quot;, 2, &quot;alma&quot;) -- &quot;2 alma&quot;string.upper(&quot;Alma&quot;) -- &quot;ALMA&quot;string.lower(&quot;Alma&quot;) -- &quot;alma&quot;&quot;string.reverse(&quot;Alma&quot;) -- &quot; amlA&quot;简写格式mystring = &quot;alma&quot;print(#mystring==mystring:len()) -- trueprint(mystring:reverse()) -- &quot;amla&quot;math.pow(x,y) -- x的y次方math.sqrt(x) -- 平方根math.max(...)math.min(...)表键值为变量或者数字必须用[]括起来可以用逗号和分号分割字符串引号可以被省略empty = {}myint = 42;mystring = &quot;China&quot;;table = { [&#39;hi&#39;] = &quot;lua&quot;, from = mystring; [empty] = &quot;empty&quot;, [myint] = 100 }for k, v in pairs(table) do print(k,v)end 表是 Lua 中唯一的数据结构， 它可被用于表示普通数组、序列、符号表、集合、记录、图、树等等。 对于记录，Lua 使用域名作为索引。 语言提供了 a.name 这样的语法糖来替代 a[“name”] 这种写法以方便记录这种结构的使用。table[“k”]==table.kprint(table.from)print(table[‘from’])array = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}print (#array) -- 3 #计算长度for k,v in ipairs(array) do print(k,v)end--1 a--2 b--3 cipairs 隐式索引，从一开始，索引都为正整数函数function f(...) -- any number of parameters a,b = ... print(a,b,...)endf(1,2,3) -- 1 2 1 2 3function foo(args) print (args.first .. args.last)endfoo{first=&quot;hello&quot;, last=&quot;world&quot;}元表及元方法 Lua 中的每个值都可以有一个元表。 这个元表就是一个普通的 Lua 表， 它用于定义原始值在特定操作下的行为。 如果你想改变一个值在特定操作下的行为，你可以在它的元表中设置对应域。 例如，当你对非数字值做加操作时， Lua 会检查该值的元表中的 “__add” 域下的函数。 如果能找到，Lua 则调用这个函数来完成加这个操作。" }, { "title": "我所理解的cocos2d-x", "url": "/posts/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84cocos2d-x/", "categories": "", "tags": "", "date": "2018-05-16 00:00:00 +0800", "snippet": "我所理解的cocos2d-x###消息分发消息机制一直是软件开发中减少模块之间耦合的标准方式。游戏中有大量的游戏对象，在这些对象之间通过消息传递而不是直接调用的方法会大大简化对象之间的交互和依赖。野指针：指针指向的内存单元已经被释放，但是其他指针可能还指向它，这些内存可能已经被重新分配给其他对象，从而导致无法预测的结果。内存泄漏：不再被使用的内存单元如果不被释放，就会一直占用内存单元，如果这些操作不断重复，就会导致内存占用不断增加。在游戏中，内存泄露引发的问题尤其严重，因为可能每一帧都在创建一个永远不会被回收的游戏对象。C++有3种管理数据内存的方式，分别是自动存储、静态存储和动态存储。其中，静态存储用于存储一些在整个应用程序执行期间都存在的静态变量，动态存储用于存储通过new关键字分配的内存单元。自动变量是一个局部变量，其作用域为包含它的代码块所对应的作用域。默认AutoreleasePool一帧被清理一次，主要是用来清理UI元素的。因为UI元素大部分都是添加到UI树中的，会一直占用内存，所以，这种情况下每帧清理并不会对内存占用有太大的影响。Cocos2d-x使用Objective-C的自动回收池机制来管理对象内存的释放。Autorelease类似于一个共享的智能指针，该智能指针的作用域为一帧，该帧结束后，它将释放自己的引用计数。此时，如果该对象没有被其他共享指针引用，则对象被释放；如果对象被引用，则保留。 对于单个的非集合元素对象，我们往往不会通过Autorelease进行管理，除非它是一个临时对象。这个时候，我们只能手动使用retain（）方法和release（）方法进行管理，这其实等价于通过new运算符和delete运算符来进行内存管理，这种情况就容易导致内存管理问题。 在对象的构造函数中分配内存，在对象的析构函数中释放内存。这就是我们前面讲述的将动态分配的内存映射到一个自动变量，通过自动变量的构造函数和析构函数来分配和释放内存，这可以保证资源始终会被释放（即使出现异常，也能被正常释放）。这也是各种智能指针（如std：：shared_ptr）的基本实现原理。通常，我们并不直接设置每个元素的世界坐标，而是设置每个元素相对于UI树父级元素的相对坐标。在绘制的时候，由引擎根据UI树对每个元素执行坐标变换，计算出世界坐标，并将位置信息发送到OpenGL ES进行绘制。一个元素的本地坐标系是以元素的左下角为原点，屏幕向右为x轴，向上为y轴。convertToNodeSpace（）方法用于将一个世界坐标转换到该元素的本地坐标系中。例如，node1的锚点为（0，0），node2的锚点为（1，1），node1位于UI树的顶层（其本地坐标等于其世界坐标），我们可以通过以下语句进行计算。 auto point=node1-&amp;gt;convertToNodeSpace(node2-&amp;gt;getPosition())node.convertToWorldSpace（nodePoint）方法则用于将一个本地坐标系中的位置转换为世界坐标系，通常父元素可以通过此方法计算一个子元素的世界坐标。注意，参数nodePoint必须表示node的子元素的位置才有意义（因为子元素处于父元素的本地坐标系中）。如果nodePoint为（0，0），则convertToWorldSpace（）方法返回的是该元素左下角的坐标，即该元素本地坐标系原点的世界坐标。如果不依赖父元素，要想计算出元素自身的世界坐标，则可以使用convertToWorldSpaceAR（）方法。该方法用于计算以该元素锚点为原点的坐标系中的某个位置的世界坐标，示例如下。node-&amp;gt;convertToWorldSpaceAR(Point::Zero)；如果一个UI树顶层的Layer的锚点为（0.5，0.5），则对该元素执行convertToWorldSpaceAR（Point：：Zero）计算的结果为屏幕中点。我们不难计算出以下关系。auto point1=node-&amp;gt;convertToWorldSpace(Point::Zero);auto point2=node-&amp;gt;convertToWorldSpaceAR(Point::Zero);auto size=node-&amp;gt;getContentSize();auto anchor=node-&amp;gt;getAnchorPoint();auto point3=Point(size.width*anchor.x,size.height*anchor.y);则point2=point1+point3。Cocos2d-x中的UI树根节点为Scene类，UI树中每个节点都是一个Node实例对象，每个Node对象具有一个children集合及一个parent节点，其中Scene的parent属性为空。渲染系统最重要的职责就是遍历UI树中的每一个元素，然后将每个元素绘制到屏幕上。UI树的遍历有两个重要的目的：其一是遍历的顺序决定了元素被绘制的顺序；其二是在遍历过程中实现元素的模型视图变换矩阵的计算，其计算结果供OpenGL ES渲染管线计算顶点位置。Cocos2d-x使用localZOrder来表示元素的逻辑深度，UI树的遍历采用中序（in-order）的深度优先算法进行遍历（参考资料6）。该方法的遍历顺序及特点如下。•遍历左边的子节点。•遍历根节点。•遍历右边的子节点逻辑深度用localZOrder属性表示，如果两个元素的逻辑深度一致，则按它们被添加到UI树中的顺序排序。这个顺序决定了每个元素被访问的顺序，因此也决定了元素最终被绘制的顺序，元素的绘制顺序还影响着事件的分发顺序，一个事件的接收者可以与一个元素相关联，最终所有的接收者按与元素的绘制顺序相反的顺序被分发。当我们创建一个Node对象时，其引用计数为1，并加入当前AutoreleasePool，所以，当前帧结束时会被释放一次。如果我们在这一帧中并没有将该对象添加到UI树中，则该对象会在帧结束的时候被释放。当我们将其加入UI树中时，Node使用Cocos2d-x自身提供的Vector来存放子元素，Vector对插入的元素执行retain（）方法，并在移除元素的时候执行release（）方法template&amp;lt;class T&amp;gt;class CC_DLL Vector{public:void pushBack(T object) { _data.push_back( object );object-&amp;gt;retain(); } void popBack() {auto last = _data.back(); _data.pop_back();last-&amp;gt;release(); }};在Cocos2d-x中，一个场景是一棵以Scene为根节点的UI树，Scene中包含一个场景的所有UI元素，如按钮、人物、道路等，每个时刻最多只有一个当前场景在运行，Director管理着当前运行的场景，并提供在不同场景之间进行切换的方法。" }, { "title": "Cocos 属性", "url": "/posts/Cocos-%E5%B1%9E%E6%80%A7/", "categories": "Cocos", "tags": "Cocos", "date": "2016-12-20 21:23:40 +0800", "snippet": "Cocos 属性智能机的普及带动手机玩家的快速增长，预计2014年依然会保持较快增幅。属性完整声明有些情况下，我们需要为属性声明添加参数，这些参数控制了属性在 属性检查器 中的显示方式，以及属性在场景序列化过程中的行为。例如：properties: {score: {default: 0,displayName: &quot;Score (player)&quot;,tooltip: &quot;The score of player&quot;,}} 以上代码为 score 属性设置了三个参数 default, displayName 和 tooltip。这几个参数分别指定了 score 的默认值为 0，在 属性检查器 里，其属性名将显示为：“Score (player)”，并且当鼠标移到参数上时，显示对应的 Tooltip。下面是常用参数： default: 设置属性的默认值，这个默认值仅在组件第一次添加到节点上时才会用到type: 限定属性的数据类型，详见 CCClass 进阶参考：type 参数visible: 设为 false 则不在 属性检查器 面板中显示该属性serializable: 设为 false 则不序列化（保存）该属性displayName: 在 属性检查器 面板中显示成指定名字tooltip: 在 属性检查器 面板中添加属性的 Tooltiptype 参数当默认值是一个枚举（cc.Enum）时，由于枚举值本身其实也是一个数字（number），所以要将 type 设置为枚举类型，才能在 属性检查器 中显示为枚举下拉框。wrap: { default: Texture.WrapMode.Clamp, type: Texture.WrapMode}url 参数如果属性是用来访问 Raw Asset 资源的 url，为了能在 属性检查器 中选取资源，或者能正确序列化，你需要指定 url 参数：texture: {default: &quot;&quot;,url: cc.Texture2D},override 参数所有属性都将被子类继承，如果子类要覆盖父类同名属性，需要显式设置 override 参数，否则会有重名警告：_id: {default: &quot;&quot;,tooltip: &quot;my id&quot;,override: true},name: {get: function () {return this._name;},displayName: &quot;Name&quot;,override: true}属性延迟定义如果两个类相互引用，脚本加载阶段就会出现循环引用，循环引用将导致脚本加载出错：Game.jsvar Item = require(&quot;Item&quot;); var Game = cc.Class({ properties: { item: { default: null, type: Item } } }); module.exports = Game;Item.js var Game = require(&quot;Game&quot;); var Item = cc.Class({ properties: { game: { default: null, type: Game } } }); module.exports = Item;上面两个脚本加载时，由于它们在 require 的过程中形成了闭环，因此加载会出现循环引用的错误，循环引用时 type 就会变为 undefined。 因此我们提倡使用以下的属性定义方式：Game.js var Game = cc.Class({ properties: () =\\&amp;gt; ({ item: { default: null, type: require(&quot;Item&quot;) } }) }); module.exports = Game;Item.js var Item = cc.Class({ properties: () =\\&amp;gt; ({ game: { default: null, type: require(&quot;Game&quot;) } }) }); module.exports = Item;这种方式就是将 properties 指定为一个 ES6 的箭头函数（lambda 表达式），箭头函数的内容在脚本加载过程中并不会同步执行，而是会被 CCClass 以异步的形式在所有脚本加载成功后才调用。因此加载过程中并不会出现循环引用，属性都可以正常初始化。箭头函数的用法符合 JavaScript 的 ES6 标准，并且 Creator 会自动将 ES6 转义为 ES5，用户不用担心浏览器的兼容问题。你可以这样来理解箭头函数：// 箭头函数支持省略掉 return 语句，我们推荐的是这种省略后的写法：properties: () =\\&amp;gt; ({ // \\&amp;lt;- 箭头右边的括号 &quot;(&quot; 不可省略game: {default: null,type: require(&quot;Game&quot;)}})// 如果要完整写出 return，那么上面的写法等价于：properties: () =\\&amp;gt; {return {game: {default: null,type: require(&quot;Game&quot;)}}; // \\&amp;lt;- 这里 return 的内容，就是原先箭头右边括号里的部分}`// 我们也可以不用箭头函数，而是用普通的匿名函数：properties: function () {return {game: {default: null,type: require(&quot;Game&quot;)}};}" }, { "title": "JavaScript之数组", "url": "/posts/article-JavaScript%E4%B9%8B%E6%95%B0%E7%BB%84/", "categories": "JavaScript", "tags": "数组", "date": "2016-10-22 05:28:23 +0800", "snippet": "数组 JavaScript数组的基本方法简介。数组元素的增删var array = [];array[0] = 22;array.push(&quot;sstd&quot;); // 尾部追加array[array.length]=521; // 尾部追加array.unshift(5); // 头部添加console.log(array);//result：[ 5, 22, &#39;sstd&#39;, 521 ]数组元素的删除delete array[1]; // 删除其中一个元素,该值变为undefined,数组长度不变console.log(array); // [ 5, , &#39;sstd&#39;, 521 ]console.log(array.length); // 4array.length -= 1; // 删除最后一个元素 console.log(array); // [ 5, , &#39;sstd&#39; ]console.log(array.length); // 3array.pop(); // 尾部删除元素console.log(array); // [ 5, ]console.log(array.length); // 2array.shift(); // 头部删除元素 console.log(array); // [ ]console.log(array.length); // 1数组遍历var array = [[1, 2, 3], [4, 5, 6]];for (var i = 0; i &amp;lt; array.length; i++)for (var j = 0; j &amp;lt; array[i].length; j++)console.log(array[i][j]);var arr = [15, 2, 110, 78, 65, 100];arr.forEach(function (x){console.log(x);})数组方法数组转字符串var arr = [1,2,3];console.log(arr.join());console.log(arr.join(&quot;-&quot;));function repeatString(str, n){return new Array(n+1).join(str);}console.log(repeatString(&quot;Hi&quot;,3));result:1,2,31-2-3HiHiHi数组逆置 数组逆置会改变原数组顺序。var arr = [1,2,3];arr.reverse();console.log(arr); // [ 3, 2, 1 ]数组排序 数组排序会改变原数组顺序。var arr = [ 15, 110, 2, &#39;d&#39;, &#39;a&#39;, &#39;c&#39; ]arr.sort();console.log(arr); // [ 110, 15, 2, &#39;a&#39;, &#39;c&#39;, &#39;d&#39; ]arr.sort(function (a, b){return a-b;});console.log(arr); // [ 2, 15, 110, &#39;a&#39;, &#39;c&#39;, &#39;d&#39; ]数组截取 数组截取不会改变原数组。var arr = [15,2,110,78,65,100];console.log(arr.slice(1)); // [ 2, 110, 78, 65, 100 ]console.log(arr.slice(1,3)); //前闭后开 [ 2, 110 ]console.log(arr.slice(1,-1)); // 去掉头尾 [ 2, 110, 78, 65 ]console.log(arr); //原数组不变 [ 15, 2, 110, 78, 65, 100 ]数组拼接 数组拼接会改变原数组。var arr = [15,2,110,78,65,100];console.log(arr.splice(2)); // [ 2, 110, 78, 65, 100 ]console.log(arr); // [ 15, 2 ]var arr = [15,2,110,78,65,100]; console.log(arr.splice(1,3)); // 一个参数为位置，第二个为删除个数 结果为 [ 2, 110, 78 ]console.log(arr); // [ 15, 65, 100 ]var arr = [15,2,110,78,65,100]; console.log(arr.splice(2,1,&quot;a&quot;,55,&quot;ss&quot;)); // [ 110 ] 从删除的位置添加元素console.log(arr); // [ 15, 2, &#39;a&#39;, 55, &#39;ss&#39;, 78, 65, 100 ]数组映射 数组映射不会改变原数组。var arr = [15, 2, 110, 78, 65, 100];console.log(arr.map(function (x){return x+100;})); // [ 115, 102, 210, 178, 165, 200 ]console.log(arr); // [ 15, 2, 110, 78, 65, 100 ]数组过滤 数组过滤不会改变原数组。var arr = [15, 2, 110, 78, 65, 100];console.log(arr.filter(function (value,index){ // 筛选出索引为偶数或者值大于100的元素return index%2===1||value&amp;gt;100;})); // [ 2, 110, 78, 100 ]console.log(arr); // [ 15, 2, 110, 78, 65, 100 ]数组判断var arr = [1, 5, 7, 6, 3, 54, 55];console.log(arr.every(function (value){ // 判断是否所有元素都大于10return value &amp;gt; 10;})); // falsevar arr = [1, 5, 7, 6, 3, 54, 55];console.log(arr.some(function (value){ // 判断是否有元素大于0return value &amp;gt; 10;})); // truereduce 每次的结果作为第一个参数。var arr = [1, 5, 7, 6, 3, 54, 55,4];console.log(arr.reduce(function (value1,value2){ // 求最大值return value1&amp;gt;value2?value1:value2;}));console.log(arr); // 55数组检索var arr = [1, 5, 7, 6, 3, 7,54, 55,4,7];console.log(arr.indexOf(7)) // 从左向右查找 2console.log(arr.indexOf(7,3)); // 第二个参数表示查找位置 5console.log(arr.indexOf(7,-2)); // 从倒数第二个元素开始查找 9console.log(arr.lastIndexOf(7)); //从右向左查找 9console.log(arr.lastIndexOf(7,-2)); //从右向左查找 5数组判断var arr = [1, 5, 7, 6, 3, 7,54, 55,4,7];console.log(Array.isArray(arr)); // trueconsole.log(arr instanceof Array); // trueconsole.log(arr.constructor === Array); // true" }, { "title": "Cocos学习笔记00", "url": "/posts/Cocos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B000/", "categories": "游戏", "tags": "Cocos creator", "date": "2016-10-05 21:05:13 +0800", "snippet": "cocos creator@(cocos学习笔记) Cocos Creator 是一款以内容创作为导向的新型游戏开发工具，它完整集成了组件化的 Cocos2d-x WEB 版本，可发布游戏到 Web，iOS，Android，Mac，Windows等平台，更支持直接发布 Cocos Play 平台，把握手机页游渠道的快速发展带来的新机遇。 Cocos2d-x 中，开发方式是以代码来驱动,在 Cocos Creator 框架中，所有场景都会被序列化为纯数据，在运行时使用这些纯数据来重新构建场景，界面，动画甚至组件等元素。 Cocos Creator 提供的是更加彻底的数据驱动方式，在编辑器中编辑的所有信息都会被序列化到数据文件中，在运行时，引擎会通过反序列化的方式将数据直接转化为对象。引擎中类的属性是可直接被序列化和反序列化的，不需要通过任何映射关系来转化。 序列化和反序列化 序列化和反序列化支持 Cocos Creator 中类的绝大多数公有属性，这些属性通过属性检查器面板暴露给开发者。开发者可以在编辑器中随意修改并保存，保存的过程就是将资源和场景数据序列化到资源数据库（Asset Database）中。反之，在加载场景的过程中，反序列化机制会根据场景数据实例化相应的对象，并还原编辑器中设置的所有属性。数据驱动的强大之处在于，用户自己编辑的组件也可以进行属性声明。这些属性可以在编辑器中被编辑，也会被保存到场景数据中，最后在运行时被反序列化到游戏场景中。资源数据库在编辑器中以资源管理器的形式呈现。 Cocos Creator 的工作流是内容创作为导向的。数据驱动使得场景可以被自由得进行编辑，不仅可以可视化得搭建整个场景，还可以对游戏逻辑进行编辑（编辑组件暴露出的属性）。这使得一切的入口点变成了编辑器，而不是代码。逻辑树和渲染树 开发者在编辑器中搭建的节点树和挂载的组件共同组成了逻辑树，其中节点构成实体单位，组件负责逻辑。逻辑树会生成场景的渲染树，决定渲染顺序，不过开发者并不需要关心这些，只要在编辑器中保障显示效果正确即可。在编辑器的 Node Tree 层级管理器中，开发者可以调整逻辑树的顺序和父子关系。 场景管理 在 Cocos Creator 中，开发者在编辑器中搭建完的场景，所有数据会保存为一个 scene-name.fire 文件，存在资源数据库（Asset Database）中。开发者可以通过 cc.director.loadScene 来加载一个场景资源，参见具体范例： var sceneName = &#39;scene-name&#39;;var onLaunched = function () { console.log(&#39;Scene &#39; + sceneName + &#39; launched&#39;);};// 第一个参数为场景的名字，第二个可选参数为场景加载后的回调函数cc.director.loadScene(sceneName, onLaunched); 此外，我们提供了访问场景节点的接口： // 获取逻辑树的场景节点var logicScene = cc.director.getScene(); 在 Cocos Creator 中，游戏场景（Scene）是开发时组织游戏内容的中心，也是呈现给玩家所有游戏内容的载体。 Canvas 打开场景后，层级管理器中会显示当前场景中的所有节点和他们的层级关系，Canvas可以被称为画布节点或渲染根节点。 组件系统变成了整个引擎的核心，组件可以以各种各样的方式扩展逻辑节点的功能。甚至可以说，逻辑节点本身不应该包含任何实际游戏逻辑，它应该由各种逻辑组件组合出完整的逻辑。 Cocos Creator 中，子节点坐标系的坐标原点就是父节点的坐标位置，也就是其锚点的位置。这样的修改对于编辑器更友好。Texture 和 SpriteFrame 资源类型 SpriteFrame 是核心渲染组件 Sprite 所使用的资源，设置或替换 Sprite 组件中的 spriteFrame 属性，就可以切换显示的图像。 图集资源（Atlas） 图集（Atlas）也称作 Sprite Sheet，是游戏开发中常见的一种美术资源。图集是通过专门的工具如TexturePacker等将多张图片合并成一张大图，并通过 plist 等格式的文件索引的资源。可供 Cocos Creator 使用的图集资源由 plist 和 png 文件组成。 在游戏中使用多张图片合成的图集作为美术资源，有以下优势：合成图集时会去除每张图片周围的空白区域，加上可以在整体上实施各种优化算法，合成图集后可以大大减少游戏包体和内存占用多个 Sprite 如果渲染的是来自同一张图集的图片时，这些 Sprite 可以使用同一个渲染批次来处理，大大减少 CPU 的运算时间，提高运行效率。字体资源 Cocos Creator 制作的游戏中可以使用三类字体资源：系统字体，动态字体和位图字体。使用 cc.Class 声明类型 cc.Class 是一个很常用的 API，用于声明 Cocos Creator 中的类，为了方便区分，我们把使用 cc.Class 声明的类叫做 CCClass。 定义 CCClass 调用 cc.Class，传入一个原型对象，在原型对象中以键值对的形式设定所需的类型参数，就能创建出所需要的类。var Sprite = cc.Class({ name: &quot;sprite&quot;}); 以上代码用 cc.Class 创建了一个类型，并且赋给了 Sprite 变量。同时还将类名设为 “sprite”，类名用于序列化，一般可以省略。 实例化: Sprite 变量保存的是一个 JavaScript 构造函数，可以直接 new 出一个对象：var obj = new Sprite();" }, { "title": "JavaScript学习笔记01", "url": "/posts/article-name-2/", "categories": "JavaScript", "tags": "JavaScript", "date": "2016-10-05 20:37:22 +0800", "snippet": "JavaScript学习笔记01原生函数 原生函数可以当做构造函数来使用，通过构造函数（如 new String(&quot;abc&quot;)）创建出来的是封装了基本类型值（如 &quot;abc&quot;）的封装对象。var string = new String(&quot;abc&quot;);console.log(string); // [String: &#39;abc&#39;]console.log(string instanceof String); // trueconsole.log(typeof string); // objectconsole.log(Object.prototype.toString.call(string)); // [object String]内部属性 所有typeof返回值为&quot;object&quot;的对象都包含了一个内部属性，可以通过Object.prototype.toString(..)查看。console.log(Object.prototype.toString.call([1,2,3])) // [object Array]console.log(Object.prototype.toString.call(true)) // [object Boolean]console.log(Object.prototype.toString.call(42)) // [object Number]封装对象包装 基本类型没有 .length和.toString()等这样的属性和方法，需要封装对象才可使用，此时JavaScript会为基本类型值自动包装成一个封装对象，浏览器对此也进行了优化，因此应优先考虑用基本类型值，而不是new String(&quot;abc&quot;)新对象。var a = &quot;abc&quot;;console.log(a.length); // 3console.log(a.toUpperCase()); //ABC 一般不推荐直接使用封装对象，如果想要自行封装基本类型值，可以使用Object(..)函数（不带new关键字）。var a = &quot;abc&quot;;var b = new String(a);var c = Object(a);console.log(typeof a); // stringconsole.log(typeof b); // objectconsole.log(typeof c); // objectconsole.log(b instanceof String); // trueconsole.log(c instanceof String); // trueconsole.log(Object.prototype.toString.call(b)); // [object String]console.log(Object.prototype.toString.call(c)); // [object String]拆封 如果想要得到封装对象的基本类型值，可以使用valueof()函数:var a = new String(&quot;abc&quot;);var b = new Boolean(true);a.valueof(); // &quot;abc&quot;b.valueof(); // true原生函数作为构造函数 构造函数Array(..)不要求必须带new关键字，不带时，系统会自动补上。Array构造函数只带一个数字参数的时候，该参数会被当做数组的预设长度，而非一个元素。var a = Array(3);console.log(a.length); // 3 创建包含undefined的数组：apply(..)是一个工具，适用于所有对象，它会以一种特殊的方式来调用传递给它的函数。第一个参数是this对象，第二个必须是一个数组（或类数组对象，array-like object），数组中的值被用作函数的参数。var a = Array.apply(null,{ length:3});console.log(a); // [ undefined, undefined, undefined ]Object(..)、Function(..)、RegExp(..) 尽量不要使用Object(..)、Function(..)、Regexp(..)，在实际情况中没有必要使用new Object()来创建对象，因为这样无法像常量形式那样一次设定多个属性，而必须逐一设定。强烈建议使用常量形式定义正则表达式，语法简单、效率高。Data(..)、Error(..) 创建日起对象必须使用new Date()。Date(..)可以带参数，用来指定日期时间，若不带参数则使用当前的如期和时间。console.log((new Date()).getDate()); // 28 构造函数Error(..),带不带new关键字都可以。function foo(x) { if (!x) throw Error(&quot;x not found&quot;);}Symbol(..) 基本数据类型，符号(Symbol)是具有唯一性的特殊值，用它来命名对象属性不容易导致重名，符号还可以自行定义，Symbol以静态属性形式出现，如Symbol.create等、不能用new关键字创建。var mysym = Symbol(&quot;abcd&quot;);console.log(mysym); // Symbol(abcd)var a = {};a[mysym] = &quot;apple&quot;;console.log(a[mysym]); // apple原生原型 原生构造函数都有自己的.prototype对象，如Array.prototype等，这些对象包含其对应子类型所有的行为特征。比如将字符串封装成字符串对象，就可以访问String.prototype中定义的方法。 根据文档约定，可将.prototype.替换为#，如String.prototype.trim()简写为String#trim()来去掉字符串的前后空格，Array#concat(..)合并数组，Number#tofixed(..)将数字转换为指定长度的整数字符串，其他对象同样如此。 Function.prototype是一个空函数，Array.prototype是一个空数组，RegExp.prototype是一个空正则表达式，对未赋值的变量来说，它们是很好的默认值，在ES6中可通过函数声明的内置语法来设置(取而代之)。" }, { "title": "你不知道的JavaScript00——原型", "url": "/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript00-%E5%8E%9F%E5%9E%8B/", "categories": "前端", "tags": "JavaScript", "date": "2016-10-05 20:21:43 +0800", "snippet": "JavaScript学习笔记00@(JavaScript) JavaScript 是一种弱类型的语言。类型 JavaScript 中的变量是没有类型，值有才类型，变量持有值的类型，类型定义了值的行为特征。 对变量执行typeof操作时，得到的是该变量持有的值的类型。 typeof运算符总会返回一个字符串。 typeof typeof 42; // &quot;string&quot; typeof 42 首先返回一个字符串 &quot;number&quot;，然后typeof &quot;number&quot;,返回 &quot;string&quot;。在作用域中声明但还没有赋值的变量为undefined，是值的一种，没有在作用域中声明过的变量为undeclared，两个不可混为一谈。 值数组与字符串 对数组声明后即可向其加入值，无需预先指定数组大小。 var arr = [ ];arr.length; // 0a[0] = 1;a[1] = &quot;2&quot;;a[2] = [3];a.length; // 3 数组不仅可以通过数字下标作为索引，也可以用包含字符串键值和属性，但这些不计入数组长度内。``` javascriptvar arr = [ ];a[0] = “2”;a[1] = 20;arr.length; // a[“apple”] = 1;a.length; // 2a[“apple”] = 1;a.apple = 1;&amp;gt; 如果字符串键值可以被强制类型转换为十进制数字的话，依旧会被当做数字索引来处理。``` javascriptvar arr = [ ];a[&quot;13&quot;] = 22;a.lenth; // 14 不建议在数组中加入字符串作为下标，建议使用数字下标。JavaScript 中的字符串是不可变的，而数组可变。字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。字符串反转：var chars = &quot;ufo&quot;;var reverseChars = chars.split(&quot;&quot;).reverse().join(&quot;&quot;)//ofuchars.split(&quot;&quot;)将字符串转换为字符数组，.reverse()将数组中的字符逆序排序，.join(&quot;&quot;)将数组中的字符拼接回字符串。数字 JavaScript 中只有一种数值类型：number(数字)，包括十进制的小数和没有小数的整数。#####数字语法数字前面的0和小数点后最后面的0可以省略,但不建议这样写。 var num = .42;var num = 42.; tofixed(..),可以指定小数部分显示的位数，输出结果为字符串形式。 toprecision(..)，用来指定有效位数。 var num = 13.1341;num.tofixed(3); // &quot;13.134&quot;num.toprecision(4); // &quot;13.13&quot;(42).tofixed(3); // &quot;42.000&quot;42..tofixed(3); // &quot;42.000&quot; 罕见0.42.tofixed(3); // &quot;0.420&quot; 罕见42.tofixed(3); // 语法错误，相当于(42)tofixed(3);42 .tofixed(3); // &quot;42.000&quot; 不推荐 进制，从ES6开始采用严格模式(strict mode)，为了代码的易读性，建议使用小写的0b、0o、0x代表二进制、八进制和十六进制。 整数检测 检测一个数是否为整数 Number.isInteger(42.0); // true 检测一个数是否为安全的整数(最大值为 Number.MAX_SAFE_NTEGER == Math.pow(2,53)-1 ) Number.isSafeInteger(Math.pow(2,53)-1); // true 特殊数值 不是值的值 undefined 数据类型只有一个的值，即 undefined，表示没有值、从未赋值，通过void 运算符即可得到该值。 null 类型也只有一个值，即 null，表示空值，目前没有值。 两者常用来表示”空值”或”不是值”的值。 特殊的数字 不是数字的数字NaN(not a number)，也可理解为”无效数值”、”坏数值”。NaN 是一个特殊值，它和自身不相等，是唯一一个非自反值(即x===x不成立)，而NaN != NaN为 true。“不是数字的数字”仍然是数字类型。 如果需要判断一个值是否是NaN，建议使用Number.isNaN(..)。 if(!Number.isNaN){Number.isNaN = function(n) {return n !== n;};}var a = 2 / &quot;foo&quot;;var b = &quot;foo&quot;;Number.isNaN( a ); // true 无穷数,相对于 Infinity， Number.MAX_ VALUE + Math.pow(2, 969) 与 Number.MAX_VALUE 更为接近，因此它被“向下取整”（ round down）；而 Number.MAX_VALUE + Math.pow(2, 970) 与 Infinity 更为接近，所以它被“向上取整”（ round up）。 var a = 1 / 0; // Infinityvar b = -1 / 0; // -Infinity 零值，加法和减法运算不会得到负零（ negative zero）。根据规范，对负零进行字符串化会返回 “0”，将其从字符串转换为数字，得到的结果是准确的。-0==0，-0===0，都为true，ES6 中新加入了一个工具方法 Object.is(..) 来判断两个值是否绝对相等。``` javascriptvar a = 0 / -3; // -0var b = 2/”foo” ; // NaN// 但是规范定义的返回结果是这样！a.toString(); // “0”a + “”; // “0”String( a ); // “0”JSON.stringify( a ); // “0” +”-0”; // -0Number( “-0” ); // -0JSON.parse( “-0” ); // -0Object.is( b, NaN ); // trueObject.is( a, -0 ); // trueObject.is( a, 0 ); // false#### 值和引用&amp;gt; 简单值（即标量基本类型值， scalar primitive） 总是通过值复制的方式来赋值 / 传递，包括 `null`、 `undefined`、字符串、数字、布尔和 ES6 中的 `symbol`。&amp;gt;&amp;gt; 复合值（ compound value）——对象（包括数组和封装对象）和函数，则总是通过引用复制的方式来赋值 / 传递。&amp;gt;引用指向的是值本身而非变量，所以一个引用无法更改另一个引用的指向。我们无法自行决定用值复制还是引用复制，一切都由值的类型来决定。&amp;gt;`Arr.slice()` 不带参数会返回当前数组的一个浅复本（ shallow copy）。由于传递给函数的是指向该复本的引用，所以 `foo(Arr.slice(..))` 中的操作不会影响 `Arr` 指向的数组。``` javascriptvar a = [1,2,3];var b = a;a; // [1,2,3]b; // [1,2,3]// 然后b = [4,5,6];a; // [1,2,3]b; // [4,5,6] 标量基本类型值是不可更改的（字符串和布尔也是如此）。如果一个数字对象的标 量基本类型值是 2，那么该值就不能更改，除非创建一个包含新值的数字对象。``` javascriptfunction foo(x) {x = x + 1;x; // 3}var a = 2;var b = new Number( a ); // Object(a)也一样foo( b );console.log( b ); // 是2，不是3function foo(wrapper) {wrapper.a = 42;}var obj = {a: 2};foo( obj );obj.a; // 42#### 隐式转换``` javascriptvar num = &quot;32&quot;+32;// &quot;3232&quot;var num = &quot;32&quot;-32;// 0 “1.23” == 1.230 == falsenull == undefinednew Object() == new Object()[1, 2] == [1, 2]/*类型不同，返回false类型相同*/NaN ≠ NaNnew Object ≠ new Objectnull === nullundefined === undefined " } ]
